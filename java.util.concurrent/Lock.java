package java.util.concurrent.locks;
import java.util.concurrent.TimeUnit;

/**
 * 与使用synchronized方法和语句相比， Lock实现提供了更广泛的锁操作。
 * 它们允许更灵活的结构，可能具有完全不同的属性，并且可能支持多个关联的Condition对象。
 *
 * 锁是一个控制多个线程访问共享资源的工具。通常，锁提供对共享资源的独占访问：
 * 每次只有一个线程可以获得锁，而对共享资源的所有访问都要求首先获得锁。
 * 但是，有些锁可能允许并发访问共享资源，比如ReadWriteLock的读锁。
 *
 * synchronized方法或语句的使用提供与每个对象关联的隐式监控锁，但促使所有锁
 * 获取和释放发生在块结构方式：在获得多个锁时，它们必须以相反的顺序被释放，而且所有的锁
 * 都必须在相同的词法作用域获取。
 *
 * 虽然synchronized方法和语句的作用域机制使用监控锁编程变得容易得多，并且有助于
 * 避免许多涉及锁的常见编程错误，但是在某些情况下，您需要以更灵活的方式使用锁。例如，一
 * 些遍历并发访问的数据结构的算法需要使用“hand-over-hand”；或者“链锁”：你获得节点A的锁，
 * 然后是节点B，然后释放A并获得C，然后释放B并获得D，以此类推。Lock接口的实现允许在
 * 不同的范围内获取和释放一个锁，并允许以任何顺序获取和释放多个锁，从而支持使用这些技术。
 *
 * 这种灵活性的增加带来了额外的处理。块结构锁的缺失消除了使用synchronized
 * 方法和语句时的锁自动释放。在大多数情况下，应该使用以下习语:
 * 
 * Lock l = ...;
 * l.lock();
 * try {
 *   // 使用该锁访问受保护的资源
 * } finally {
 *   l.unlock();
 * }}
 *
 * 当锁定和解锁发生在不同的范围时，必须注意确保锁被持有时执行的所有代码都受到
 * try-finally或try-catch的保护，以确保锁在必要时被释放
 *
 * Lock实现提供超过synchronized同步方法和语句的使用方法，
 * 通过提供一个非阻塞的尝试获得一个锁tryLock()，尝试获得锁可以被中
 * 断lockInterruptibly，企图获得锁也可以设置超时tryLock(long, TimeUnit)。
 *
 * Lock类还可以提供与隐式监控锁截然不同的行为和语义，例如保证顺序、不可重入使用或死锁检测。
 * 如果实现提供了这种特殊的语义，那么实现必须记录这些语义。
 *
 * 注意，Lock实例只是普通对象，它们本身可以用作synchronized语句中的目标。获取
 * lock实例的监控锁与请求该实例的任何lock方法没有指定的关系。为了避免混淆，建议
 * 您永远不要以这种方式使用Lock实例，除非在它们自己的实现中使用。
 *
 * 除非特别指出，为任何参数传递一个null值都会导致抛出一个NullPointerException。
 *
 * 内存同步:
 *
 * 所有Lock实现必须强制执行内置监控锁提供的相同内存同步语义，如Java™语言规范的
 * 第17.4章节描述的：
 *    一个成功的lock操作与一个成功的 lock 动作具有相同的内存同步效果。
 *    一个成功的unlock操作与成功的 unlock 操作具有相同的内存同步效果。
 *
 * 不成功的锁定和解锁操作以及可重入锁定/解锁操作不需要任何内存同步效果。
 *
 * 实现考虑:
 *
 * 三种形式的锁获取(可中断、不可中断和定时)在性能特征、顺序保证或其他实现质量方面可能有所不同。
 * 此外，在给定的lock类中可能无法中断正在进行的获取锁。因此，实现不需要为所有三种形式的
 * 锁获取定义完全相同的保证或语义，也不需要支持中断正在进行的锁获取。需要一个实现来清楚地记录每种
 * 锁定方法提供的语义和保证。它还必须遵守这个接口中定义的中断语义，只要支持锁获取中断：要么完全支
 * 持，要么只支持方法入口。
 *
 * 由于中断通常意味着取消，对中断的检查通常不频繁，所以实现可能更倾向于响应中断而不是正常的
 * 方法返回。即使可以显示在另一个操作之后发生的中断可能已经解除了线程阻塞，这也是正确的。实现应
 * 该记录这种行为。
 * 
 * @see ReentrantLock
 * @see Condition
 * @see ReadWriteLock
 *
 * @since 1.5
 * @author Doug Lea
 */
public interface Lock {

    /**
     * 请求锁
     *
     * 如果锁不可用，那么出于线程调度的目的，当前线程将被禁用，并处于休眠状态，直到获得锁为止。
     *
     * 实现考虑:
     *      实现可能能够检测到锁的错误使用，例如调用会导致死锁，并可能在这种情况下抛出
     *      异常。环境和异常类型必须由{@code Lock}实现记录。
     */
    void lock();

    /**
     * 获取锁，除非当前线程被中断。如果锁可用，则获取锁并立即返回。
     *
     * 如果锁不可用，那么当前线程将出于线程调度的目的被禁用，并处于休眠状态，直到发生以下两种情况之一:
     *
     *  1.锁被当前线程获取
     *  2.当前线程被其他线程打断（支持锁获取的中断）。
     */
    void lockInterruptibly() throws InterruptedException;

    boolean tryLock();

    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    void unlock();

    Condition newCondition();
}
